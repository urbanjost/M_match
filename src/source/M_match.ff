!09/22/1980  15:38:34
!04/19/2020  11:05:06
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file M_match.3m_match.man
NAME
   M_match(3fp) - [M_MATCH] Basic Regular Expressions
   (LICENSE:PD)
SYNOPSIS
   use M_match, only: match, amatch, getpat, makpat
   use M_match, only: YES, MAXPAT, MAXARG, MAXLINE, EOS, NEWLINE, ERR

DESCRIPTION
   Find a string matching a regular expression.

      *   zero or more occurrences of the previous character
      .   any character
      ^   beginning of line
      $   end of line
      []  class of characters. Inside the braces

           ^  at the beginning of the class means to
              negate the class.
           -  if not the first or last character in
              the class, denotes a range of characters
      Escape characters:
       \\n  newline
       \\r  carriage return
       \\t  tab
       \\b  backspace
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
module M_match
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit
implicit none
private
public :: getpat  !....... encode regular expression for pattern matching
public :: match   !....... match pattern anywhere on line
public :: amatch  !....... look for pattern matching regular expression
public :: makpat  !....... encode regular expression for pattern matching
public :: regex_pattern
public :: bpos, epos
private :: omatch
private :: error
private :: addset
private :: dodash
private :: locate
private :: patsiz
private :: stclos
private :: getccl
private :: filset
private :: esc

integer,parameter,public :: MAXTAGS=10

interface getpat;     module procedure getpat_, getpat__;           end interface
interface makpat;     module procedure makpat_          ;           end interface
interface amatch;     module procedure amatch_, amatch__;           end interface
interface match;      module procedure match_,  match__ ;           end interface
interface omatch;     module procedure omatch_          ;           end interface

!========== STANDARD RATFOR DEFINITIONS ==========
!x!integer,parameter :: CHARACTER=INTEGER
integer,parameter :: chr=kind(1)
integer,parameter :: byte=kind(1)
integer,parameter :: def=kind(1)
!x!integer,parameter :: ANDIF=IF

integer(kind=byte),parameter :: EOF=10003_byte
integer(kind=byte),parameter,public :: EOS=10002_byte
integer(kind=byte),parameter,public :: ERR=10001_byte
integer(kind=byte),parameter,public :: YES=1_byte
!x!integer(kind=byte),parameter :: ARB=100_byte

integer(kind=byte),parameter :: ACCENT=96_byte
integer(kind=byte),parameter :: AND=38_byte
integer(kind=byte),parameter :: ATSIGN=64_byte
integer(kind=byte),parameter :: BACKSLASH=92_byte
integer(kind=byte),parameter :: BACKSPACE=8_byte
integer(kind=byte),parameter :: CR=13_byte
integer(kind=byte),parameter :: BANG=33_byte
integer(kind=byte),parameter :: BAR=124_byte
integer(kind=byte),parameter :: BIGA=65_byte
integer(kind=byte),parameter :: BIGB=66_byte
integer(kind=byte),parameter :: BIGC=67_byte
integer(kind=byte),parameter :: BIGD=68_byte
integer(kind=byte),parameter :: BIGE=69_byte
integer(kind=byte),parameter :: BIGF=70_byte
integer(kind=byte),parameter :: BIGG=71_byte
integer(kind=byte),parameter :: BIGH=72_byte
integer(kind=byte),parameter :: BIGI=73_byte
integer(kind=byte),parameter :: BIGJ=74_byte
integer(kind=byte),parameter :: BIGK=75_byte
integer(kind=byte),parameter :: BIGL=76_byte
integer(kind=byte),parameter :: BIGM=77_byte
integer(kind=byte),parameter :: BIGN=78_byte
integer(kind=byte),parameter :: BIGO=79_byte
integer(kind=byte),parameter :: BIGP=80_byte
integer(kind=byte),parameter :: BIGQ=81_byte
integer(kind=byte),parameter :: BIGR=82_byte
integer(kind=byte),parameter :: BIGS=83_byte
integer(kind=byte),parameter :: BIGT=84_byte
integer(kind=byte),parameter :: BIGU=85_byte
integer(kind=byte),parameter :: BIGV=86_byte
integer(kind=byte),parameter :: BIGW=87_byte
integer(kind=byte),parameter :: BIGX=88_byte
integer(kind=byte),parameter :: BIGY=89_byte
integer(kind=byte),parameter :: BIGZ=90_byte
integer(kind=byte),parameter,public :: BLANK=32_byte
integer(kind=byte),parameter :: CARET=94_byte
integer(kind=byte),parameter :: COLON=58_byte
integer(kind=byte),parameter :: COMMA=44_byte
integer(kind=byte),parameter :: DIG0=48_byte
integer(kind=byte),parameter :: DIG1=49_byte
integer(kind=byte),parameter :: DIG2=50_byte
integer(kind=byte),parameter :: DIG3=51_byte
integer(kind=byte),parameter :: DIG4=52_byte
integer(kind=byte),parameter :: DIG5=53_byte
integer(kind=byte),parameter :: DIG6=54_byte
integer(kind=byte),parameter :: DIG7=55_byte
integer(kind=byte),parameter :: DIG8=56_byte
integer(kind=byte),parameter :: DIG9=57_byte
integer(kind=byte),parameter :: DIGIT=2_byte
integer(kind=byte),parameter :: DOLLAR=36_byte
integer(kind=byte),parameter :: DQUOTE=34_byte
integer(kind=byte),parameter :: EQUALS=61_byte
integer(kind=byte),parameter :: ERROUT=2_byte
integer(kind=byte),parameter :: GREATER=62_byte
integer(kind=byte),parameter :: LBRACE=123_byte
integer(kind=byte),parameter :: LBRACK=91_byte
integer(kind=byte),parameter :: LESS=60_byte
integer(kind=byte),parameter :: LETA=97_byte
integer(kind=byte),parameter :: LETB=98_byte
integer(kind=byte),parameter :: LETC=99_byte
integer(kind=byte),parameter :: LETD=100_byte
integer(kind=byte),parameter :: LETE=101_byte
integer(kind=byte),parameter :: LETF=102_byte
integer(kind=byte),parameter :: LETG=103_byte
integer(kind=byte),parameter :: LETH=104_byte
integer(kind=byte),parameter :: LETI=105_byte
integer(kind=byte),parameter :: LETJ=106_byte
integer(kind=byte),parameter :: LETK=107_byte
integer(kind=byte),parameter :: LETL=108_byte
integer(kind=byte),parameter :: LETM=109_byte
integer(kind=byte),parameter :: LETN=110_byte
integer(kind=byte),parameter :: LETO=111_byte
integer(kind=byte),parameter :: LETP=112_byte
integer(kind=byte),parameter :: LETQ=113_byte
integer(kind=byte),parameter :: LETR=114_byte
integer(kind=byte),parameter :: LETS=115_byte
integer(kind=byte),parameter :: LETT=116_byte
integer(kind=byte),parameter :: LETTER=1_byte
integer(kind=byte),parameter :: LETU=117_byte
integer(kind=byte),parameter :: LETV=118_byte
integer(kind=byte),parameter :: LETW=119_byte
integer(kind=byte),parameter :: LETX=120_byte
integer(kind=byte),parameter :: LETY=121_byte
integer(kind=byte),parameter :: LETZ=122_byte
integer(kind=byte),parameter :: LPAREN=40_byte
!x!integer(kind=byte),parameter :: MAXCHARS=20_byte
integer(kind=byte),parameter,public :: MAXLINE=1024_byte       ! TYPICAL LINE LENGTH
!x!integer(kind=byte),parameter :: MAXNAME=30_byte        ! TYPICAL FILE NAME SIZE
integer(kind=byte),parameter :: MINUS=45_byte
integer(kind=byte),parameter :: NEWLINE=10_byte
integer(kind=byte),parameter,public :: NO=0_byte
integer(kind=byte),parameter :: NOERR=0_byte
integer(kind=byte),parameter :: NOT=126_byte           ! SAME AS TILDE
integer(kind=byte),parameter :: OK=-2_byte
integer(kind=byte),parameter :: OR=BAR             ! SAME AS BAR
integer(kind=byte),parameter :: PERCENT=37_byte
integer(kind=byte),parameter :: PERIOD=46_byte
integer(kind=byte),parameter :: PLUS=43_byte
integer(kind=byte),parameter :: QMARK=63_byte
integer(kind=byte),parameter :: RBRACE=125_byte
integer(kind=byte),parameter :: RBRACK=93_byte
integer(kind=byte),parameter :: READ=0_byte
integer(kind=byte),parameter :: READWRITE=2_byte
integer(kind=byte),parameter :: RPAREN=41_byte
integer(kind=byte),parameter :: SEMICOL=59_byte
integer(kind=byte),parameter :: SHARP=35_byte
integer(kind=byte),parameter :: SLASH=47_byte
integer(kind=byte),parameter :: SQUOTE=39_byte
integer(kind=byte),parameter :: STAR=42_byte
integer(kind=byte),parameter :: TAB=9_byte
integer(kind=byte),parameter :: TILDE=126_byte
integer(kind=byte),parameter :: UNDERLINE=95_byte
integer(kind=byte),parameter :: WRITE=1_byte

! HANDY MACHINE-DEPENDENT PARAMETERS, CHANGE FOR A NEW MACHINE
integer(kind=byte),parameter,public  :: MAXPAT=512
integer(kind=byte),parameter,public  :: MAXARG=512
integer(kind=byte),parameter :: MAXSUBS=10

integer(kind=byte),parameter :: COUNT=1
integer(kind=byte),parameter :: PREVCL=2
integer(kind=byte),parameter :: START=3
integer(kind=byte),parameter :: CLOSIZE=4

!x!integer(kind=byte),parameter  :: ESCAPE=ATSIGN
!x!integer(kind=byte),parameter  :: ANY=QMARK
!x!integer(kind=byte),parameter  :: BOL=PERCENT

integer(kind=byte),parameter   :: EOL=DOLLAR
integer(kind=byte),parameter   :: CLOSURE=STAR
integer(kind=byte),parameter   :: DASH=MINUS
integer(kind=byte),parameter   :: ESCAPE=BACKSLASH
integer(kind=byte),parameter   :: ANY=PERIOD
integer(kind=byte),parameter   :: BOL=CARET

integer(kind=byte),parameter :: CCL=LBRACK
integer(kind=byte),parameter :: CCLEND=RBRACK

integer(kind=byte),parameter :: NCCL=LETN
integer(kind=byte),parameter :: CHAR=LETA
integer(kind=byte),parameter :: BOSS=LBRACE        ! <
integer(kind=byte),parameter :: EOSS=RBRACE        ! >

!x!COMMON /CSUBS/ BPOS(MAXSUBS), EPOS(MAXSUBS)
integer(kind=byte) ::  bpos(maxsubs)           ! beginning of partial match
integer(kind=byte) ::  epos(maxsubs)           ! end of corresponding partial match

type :: regex_pattern
   integer :: pat(MAXPAT)
end type regex_pattern

contains
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
function f2r(string,isize)

character(len=*),parameter::ident_1="&
&@(#)M_match::f2r(3f): convert Fortran character variable to Ratfor integer array with Ratfor terminator"

character(len=*),intent(in) :: string
integer,intent(in)          :: isize
!!integer                     :: f2r(len(string)+1)
integer                     :: f2r(isize)
integer                     :: i
f2r=blank
   do i=1,len_trim(string)
      f2r(i)=ichar(string(i:i))
   enddo
   f2r(i)=eos
end function f2r
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
function r2f(ints)

character(len=*),parameter::ident_2="@(#)M_match::r2f(3f): convert Ratfor integer array to Fortran character variable"

integer,intent(in)          :: ints(:)
character(len=size(ints)-1) :: r2f
integer                     :: i
intrinsic char
   r2f=' '
   do i=1,size(ints)-1
      if(ints(i).eq.eos)then
         exit
      endif
      r2f(i:i)=char(ints(i))
   enddo
end function r2f
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file getpat.3m_match.man
NAME
   getpat(3f) - [M_MATCH] convert str into pattern
   (LICENSE:PD)
SYNOPSIS
integer function getpat(str, pat)
DESCRIPTION
   convert str into pattern
OPTIONS
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function getpat_(arg, pat)

$@(#) M_match::getpat_ convert argument into pattern

integer(kind=def) :: getpat_
integer(kind=def) :: arg(maxarg)
integer(kind=def) :: pat(maxpat)
   getpat_ = makpat_(arg, 1, EOS, pat)
end function getpat_
!===================================================================================================================================
function getpat__(arg_str, pat)

character(len=*),intent(in)   :: arg_str
integer(kind=def),intent(out) :: pat(maxpat)
integer(kind=def)             :: getpat__
integer(kind=def)             :: arg(maxarg)
integer                       :: len_arg_str

   len_arg_str=len(arg_str)
   if(len_arg_str.gt.MAXARG-1)then
      write(*,*)'*getpat* error: input arg_str too long,',len_arg_str,' > ',MAXARG-1
      stop
   endif
   arg=f2r(arg_str,size(arg))
   getpat__ = makpat_(arg, 1, eos, pat)
end function getpat__
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file PRIVATE/addset.3m_match.man
NAME
   addset(3f) - [M_MATCH] put c in string(J) if it fits, increment J
   (LICENSE:PD)
SYNOPSIS
integer function addset(c, str, j, maxsiz)
DESCRIPTION
  put c in string(j) if it fits, increment
OPTIONS
RETURNS
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function addset(c, set, j, maxsiz)

$@(#) M_match::addset put C in SET(J) if it fits, increment J

integer(kind=byte)            :: addset
integer(kind=chr),intent(in)  :: c
integer(kind=chr)             :: set(:)
integer(kind=byte)            :: j
integer(kind=byte),intent(in) :: maxsiz
   if (j > maxsiz)then
      addset = NO
   else
      set(j) = c
      j = j + 1
      addset = YES
   endif
end function addset
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file PRIVATE/dodash.3m_match.man
NAME
   dodash(3f) - [M_MATCH] expand array(i-1)-array(i+1) into set(j)... from valid
   (LICENSE:PD)
SYNOPSIS
subroutine dodash(valid, array, i, set, j, maxset)
DESCRIPTION
   expand array(i-1)-array(i+1) into set(j)... from valid
OPTIONS
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
! dodash - expand array(i-1)-array(i+1) into set(j)... from valid
subroutine dodash(valid, array, i, set, j, maxset)
integer(kind=def) ::  i, j, junk, k, limit, maxset
character(len=*),intent(in) :: valid
integer(kind=chr) :: array(:)
integer(kind=chr) :: set(:)
intrinsic char
   i = i + 1
   j = j - 1
   limit = index(valid, char(esc(array, i)))
   k=index(valid,char(set(j)))
   do
      if(.not. (k.le.limit)) exit
      junk = addset(ichar(valid(k:k)), set, j, maxset)
      k=k+1
   enddo
end subroutine dodash
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file PRIVATE/locate.3m_match.man
NAME
   locate(3f) - [M_MATCH] look for c in char class at pat(offset)
   (LICENSE:PD)
SYNOPSIS
    pure integer function locate(c, pat, offset)
DESCRIPTION
   look for c in char class at pat(offset)
OPTIONS
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
pure function locate(c, pat, offset)

$@(#) M_match::locate look for c in char class at pat(offset)

integer(kind=def)            :: locate
integer(kind=chr),intent(in) :: c
integer(kind=chr),intent(in) :: pat(maxpat)
integer(kind=def),intent(in) :: offset
integer(kind=def)            :: i
   ! size of class is at pat(offset), characters follow

   !x!for (i = offset + pat(offset); i > offset; i = i - 1)

   locate = NO
   LOC: do i = offset + pat(offset), offset+1,  -1
      if (c == pat(i)) then
         locate = YES
	 exit LOC
      endif
   enddo LOC
end function locate
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file match.3m_match.man
NAME
   match(3f) - [M_MATCH] find match to a basic regular expression anywhere on input string
   (LICENSE:PD)

SYNOPSIS
   integer function match(line, pattern)

    character(len=*),intent(in) :: line
    integer,intent(in)          :: pattern(MAXPAT)

DESCRIPTION
 Given a BRE(Basic Regular Expression) converted to a pattern
 return whether an input string matches it.

OPTIONS
   LIN  string to search for a match to the pattern
   PAT  pattern generated from a BRE using getpat(3f) or makpat(3f).

EXAMPLE
   Sample program:

    program demo_match
    use :: M_match, only : getpat, match
    use :: M_match, only : MAXPAT, MAXARG, MAXLINE, YES, ERR
    implicit none
    ! find _ find patterns in text
    integer                      :: pat(MAXPAT)
    character(len=MAXARG-1)      :: argument
    integer                      :: stat
    integer                      :: ios
    integer                      :: len_arg
    character(len=MAXLINE-2)     :: line
    call get_command_argument(1, argument,status=stat,length=len_arg)
    if(stat.ne.0.or.argument.eq.'')then
       write(*,*)"usage: find pattern."
    elseif(getpat(argument(:len_arg), pat) .eq. ERR) then
       write(*,*)"illegal pattern."
    else
       INFINITE: do
          read(*,'(a)',iostat=ios)line
          if(ios.ne.0)exit
          if(match(trim(line), pat) .eq. YES) then
             write(*,'(*(a))')trim(line)
          endif
       enddo INFINITE
    endif
    end program demo_match

AUTHOR
  John S. Urban

REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976

LICENSE
  Public Domain

$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function match_(lin, pat)

$@(#) M_match::match find match anywhere on line

integer(kind=def) :: match_
integer(kind=chr) :: lin(maxline), pat(maxpat)
integer(kind=def) :: i

   if (pat(1) == bol) then            ! anchored match
      if (amatch_(lin, 1, pat) > 0) then
         match_ = yes
         return
      endif
   else               ! unanchored
      !- for (i = 1; lin(i) /= eos; i = i + 1)
      i=1
      do while (lin(i) /= eos)
         if (amatch_(lin, i, pat) > 0) then
            match_ = yes
            return
         endif
         i=i+1
      enddo
   endif
   match_ = no
end function match_
!==================================================================================================================================!
function match__(lin_str, pat)

$@(#) M_match::match find match anywhere on line

character(len=*),intent(in) :: lin_str
integer(kind=def) :: match__
integer(kind=chr) :: lin(maxline), pat(maxpat)
   lin=f2r(lin_str,size(lin))
   match__=match_(lin,pat)
end function match__
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file PRIVATE/patsiz.3m_match.man
NAME
   patsiz(3f) - [M_MATCH] returns size of pattern entry at pat(n)
   (LICENSE:PD)
SYNOPSIS
integer function patsiz(pat, n)
DESCRIPTION
 returns size of pattern entry at pat(n)
OPTIONS
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function patsiz(pat, n)

$@(#) M_match::patsiz returns size of pattern entry at pat(n)

integer(kind=def) :: patsiz
integer(kind=chr) :: pat(MAXPAT)
integer(kind=def) :: n

   select case(pat(n))
    case(CHAR,BOSS,EOSS)
      patsiz = 2
    case(BOL,EOL,ANY)
      patsiz = 1
    case(CCL,NCCL)
      patsiz = pat(n + 1) + 2
    case(CLOSURE)                  ! optional
      patsiz = CLOSIZE
    case default
      call error("in patsiz: cannot happen.")
   end select

end function patsiz
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file PRIVATE/stclos.3m_match.man
NAME
   stclos(3f) - [M_MATCH] insert CLOSURE entry at pat(j)
   (LICENSE:PD)
SYNOPSIS
integer function stclos(pat, j, lastj, lastcl)
DESCRIPTION
 insert CLOSURE entry at pat(j)
OPTIONS
RETURNS
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function stclos(pat, j, lastj, lastcl)

$@(#) M_match::stclos insert closure entry at pat(j)

integer(kind=def) :: stclos
integer(kind=chr) :: pat(maxpat)
integer(kind=def) :: j, jp, jt, junk, lastcl, lastj

   !- for (jp = j - 1; jp >= lastj; jp = jp - 1) <   ! make a hole
   do jp = j - 1, lastj,  - 1   ! make a hole
      jt = jp + closize
      junk = addset(pat(jp), pat, jt, maxpat)
   enddo
   j = j + closize
   stclos = lastj
   junk = addset(closure, pat, lastj, maxpat)   ! put closure in it
   junk = addset(0, pat, lastj, maxpat)      ! count
   junk = addset(lastcl, pat, lastj, maxpat)   ! prevcl
   junk = addset(0, pat, lastj, maxpat)      ! start
end function stclos
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file PRIVATE/getccl.3m_match.man
NAME
   getccl(3f) - [M_MATCH] expand char class at arg(i) into pat(j)
   (LICENSE:PD)
SYNOPSIS
integer function getccl(arg, i, pat, j)
DESCRIPTION
   expand char class at arg(i) into pat(j)
OPTIONS
   ARG  ADE string array
   I    index into ARG
   PAT  encoded regular expression
   J    .
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function getccl(arg, i, pat, j)

$@(#) M_match::getccl expand char class at arg(i) into pat(j)

integer(kind=def) :: getccl
integer(kind=chr)  :: arg(maxarg), pat(maxpat)
integer(kind=def) :: i, j, jstart, junk

   i = i + 1      ! skip over [
   if (arg(i) == tilde .or. arg(i) == caret) then
      junk = addset(nccl, pat, j, maxpat)
      i = i + 1
   else
      junk = addset(ccl, pat, j, maxpat)
   endif
   jstart = j
   junk = addset(0, pat, j, maxpat)      ! leave room for count
   call filset(cclend, arg, i, pat, j, maxpat)
   pat(jstart) = j - jstart - 1
   if (arg(i) == cclend)then
      getccl = ok
   else
      getccl = err
   endif
end function getccl
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file PRIVATE/filset.3m_match.man
NAME
   filset(3f) - [M_MATCH] expand set at array(i) into set(j), stop at delim
   (LICENSE:PD)
SYNOPSIS
subroutine filset(delim, array, i, set, j, maxset)
DESCRIPTION
  expand set at array(i) into set(j), stop at delim
OPTIONS
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
subroutine filset(delim, array, i, set, j, maxset)

$@(#) M_match::filset expand set at  array(i)  into  set(j),  stop at  delim

integer(kind=def) :: i, j, junk, maxset
integer(kind=chr) :: array(:), delim, set(:)

character(len=*),parameter :: digits= "0123456789"
character(len=*),parameter :: lowalf= "abcdefghijklmnopqrstuvwxyz"
character(len=*),parameter :: upalf= "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
intrinsic char

   !-  for ( ; array(i) /= delim .and. array(i) /= eos; i = i + 1)
   do while( array(i) /= delim .and. array(i) /= eos)
      if (array(i) == escape) then
         junk = addset(esc(array, i), set, j, maxset)
      elseif (array(i) /= dash) then
         junk = addset(array(i), set, j, maxset)
      elseif (j <= 1 .or. array(i+1) == eos) then   ! literal -
         junk = addset(dash, set, j, maxset)
      elseif (index(digits, char(set (j - 1))) > 0) then
         call dodash(digits, array, i, set, j, maxset)
     elseif (index(lowalf, char(set (j - 1))) > 0) then
         call dodash(lowalf, array, i, set, j, maxset)
      elseif (index(upalf, char(set (j - 1))) > 0) then
         call dodash(upalf, array, i, set, j, maxset)
      else
         junk = addset (DASH, set, j, maxset)
      endif
      i=i+1
   enddo
end subroutine filset
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file PRIVATE/esc.3m_match.man
NAME
   esc(3f) - [M_MATCH] map array(i) into escaped character if appropriate
   (LICENSE:PD)
SYNOPSIS
   integer function esc(array, i)
   integer,intent(in) :: array(*)
   integer            :: i

DESCRIPTION
   To support commonly used non-printable characters escaped strings are
   supported. When the ESCAPE character is encountered the following
   character is examined. If one of the special characters ESC(3f) will
   increment I and return the designated non-printable character. Otherwise
   it will return the character as-is.

   o convert \n to newline
   o convert \t to horizontal tab
   o convert \r to carriage return
   o convert \b to backspace
   o convert \nnn to character represented by octal value

OPTIONS
   ARRAY  array of ADE (ASCII Decimal Equivalent) values terminated by
          an EOS (End-Of-String) character representing a string to scan
          for escaped characters.
   I      pointer into ARRAY. It is incremented to the position of the
          next character in ARRAY on return.

RETURNS
   ESC    The ADE for the substituted character

EXAMPLE

AUTHOR
  John S. Urban

REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976

LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function esc(array, i)

$@(#) M_match::esc map  array(i)  into escaped character if appropriate

integer(kind=chr) :: esc
integer(kind=chr) :: array(:)
integer(kind=def) :: i

   if (array(i) /= escape)then                         ! if not an escape character, return the character as-is
      esc = array(i)
   elseif (array(i+1) == eos)then                      ! if ESCAP is the last character it is left as-is and is not special
      esc = escape
   else
      i = i + 1                                        ! increment I to look at character after ESCAP
      select case(array(i))                            ! make substitution to special character for designated characters
      case(ichar('n'),ichar('N'));  esc = newline
      case(ichar('t'),ichar('T')); esc = tab
      case(ichar('b'),ichar('B')); esc = backspace
      case(ichar('r'),ichar('R')); esc = cr
      case(dig0:dig7)
         !- for (esc = 0; array(i) >= dig0 .and. array(i) <= dig7; i = i + 1)
         esc=0
         do while (array(i) >= dig0 .and.  array(i) <= dig7)
            i = i + 1
            esc = 8*esc + array(i) - dig0
            i = i - 1                                  ! so like other cases
         enddo
      case default
         esc = array(i)                                ! otherwise just copy character
      end select
   endif
end function esc
!----------------------------------------------------------------------------------------------------------------------------------!
! Conventional C Constants
!   Oct  Dec  Hex  Char
!   -----------------------
!   000  0    00   NUL '\0'   Null
!   007  7    07   BEL '\a'   Bell
!  *010  8    08   BS  '\b'   Backspace
!  *011  9    09   HT  '\t'   Horizontal Tab
!  *012  10   0A   LF  '\n'   Line Feed
!   013  11   0B   VT  '\v'   Vertical Tab
!   014  12   0C   FF  '\f'   Form Feed
!  *015  13   0D   CR  '\r'   Carriage Return
!   134  92   5C   \   '\\'   Backslash
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file PRIVATE/omatch.3m_match.man
NAME
   omatch(3f) - [M_MATCH] try to match a single pattern at pat(j)
   (LICENSE:PD)
SYNOPSIS
integer function omatch(lin, i, pat, j)
DESCRIPTION
   try to match a single pattern at pat(j)
OPTIONS
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function omatch_(lin, i, pat, j)

$@(#) M_match::omatch_ try to match a single pattern at pat(j)

integer(kind=def) ::  omatch_
integer(kind=chr)  :: lin(maxline), pat(maxpat)
integer(kind=def) :: bump, i, j, k

   omatch_ = no
   if (lin(i) == eos)then
      return
   endif
   bump = -1
   if (pat(j) == char) then
      if (lin(i) == pat(j + 1))then
         bump = 1
      endif
   elseif (pat(j) == bol) then
      if (i == 1)then
         bump = 0
      endif
   elseif (pat(j) == any) then
      if (lin(i) /= newline)then
         bump = 1
      endif
   elseif (pat(j) == eol) then
      if (lin(i) == newline .or. lin(i) == eos)then
         bump = 0
      endif
   elseif (pat(j) == ccl) then
      if (locate(lin(i), pat, j + 1) == yes)then
         bump = 1
      endif
   elseif (pat(j) == nccl) then
      if (lin(i) /= newline .and. locate(lin(i), pat, j + 1) == no)then
         bump = 1
      endif
   elseif (pat(j) == boss) then
      k = pat(j+1)
      bpos(k+1) = i
      bump = 0
   elseif (pat(j) == eoss) then
      k = pat(j+1)
      epos(k+1) = i
      bump = 0
   else
      call error("in omatch_: can't happen.")
   endif
   if (bump >= 0) then
      i = i + bump
      omatch_ = yes
   endif
end function omatch_
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file amatch.3m_match.man
NAME
   amatch(3f) - [M_MATCH] look for pattern matching regular expression; returns its location
   (LICENSE:PD)
SYNOPSIS
   loc = amatch(line, from, pat, tagbeg, tagend)

    character(len=*),intent(in) :: line
    integer,intent(in)          :: from
    character                   :: pat(MAXPAT)
    integer                     :: tagbeg(MAXTAGS), tagend(MAXTAGS)
    integer                     :: loc
DESCRIPTION
   AMATCH scans LINE starting at location FROM, looking
   for a pattern which matches the regular expression coded
   in PAT. If the pattern is found, its starting location
   in LINE is returned. If the pattern is not found, AMATCH
   returns 0.

   The regular expression in PAT must have been previously
   encoded by GETPAT(3f) or MAKPAT(3f). (For a complete description
   of regular expressions, see the manpage for M_match.)

   AMATCH(3f) is a special-purpose version of MATCH(3f), which should
   be used in most cases.
OPTIONS
   LINE           input line to scan
   FROM           beginning location to start scan from
   PAT            coded regular expression encoded by GETPAT(3f) or MAKPAT(3f)
   TAGBEG,TAGEND  element "i + 1" returns start or end, respectively, of "i"th tagged subpattern
RETURNS
   LOC   returns location match was found or zero (0) if no match remains
EXAMPLE
  Sample program:

    program demo_amatch
    use :: M_match, only : getpat, amatch
    use :: M_match, only : MAXPAT, MAXARG, MAXLINE, MAXTAGS, YES, ERR
    implicit none
    ! find _ find patterns in text
    integer                      :: pat(MAXPAT)
    character(len=MAXARG-1)      :: argument
    integer                      :: stat
    integer                      :: ios
    integer                      :: len_arg
    integer                      :: loc
    integer                      :: ii
    character(len=MAXLINE-2)     :: line
    integer                      :: tagbeg(MAXTAGS),tagend(MAXTAGS)
    call get_command_argument(1, argument,status=stat,length=len_arg)
    if(stat.ne.0.or.argument.eq.'')then
       write(*,*)"usage: find pattern."
    elseif(getpat(argument(:len_arg), pat) .eq. ERR) then
       write(*,*)"illegal pattern."
    else
       INFINITE: do
          read(*,'(a)',iostat=ios)line
          tagbeg=-9999;tagend=-9999
          if(ios.ne.0)exit
          loc = amatch(trim(line), 1, pat, tagbeg, tagend) ! returns location/0
          if(loc.gt.0)then ! matched; if no match, loc is returned as 0
             write(*,'(*(a))')trim(line)
             ! (element "i + 1" returns start or end, respectively, of "i"th tagged subpattern)
             write(*,'(*(i0,1x,i0,1x,i0,/))')(ii,tagbeg(ii),tagend(ii),ii=1,size(tagbeg))
          endif
       enddo INFINITE
    endif
    end program demo_amatch

SEE ALSO
   match, getpat, makpat
DIAGNOSTICS
   None
AUTHOR
   John S. Urban
REFERENCE
   "Software Tools" by Kernighan and Plauger , 1976
LICENSE
   Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function amatch_(lin, from, pat)

$@(#) M_match::amatch_  (non-recursive) look for match starting at lin(from)

integer(kind=def) :: amatch_
integer(kind=chr)  :: lin(maxline), pat(maxpat)
integer(kind=def) :: from, i, j, offset, stack
   stack = 0
   offset = from      ! next unexamined input character
!-   for (j = 1; j <= maxsubs; j = j + 1) <     ! clear partial match results
   do j = 1, maxsubs     ! clear partial match results
      bpos(j) = offset
      epos(j) = offset
   enddo
!-   for (j = 1; pat(j) /= eos; j = j + patsiz(pat, j))
   j=1
   do while (pat(j) /= eos)
      if (pat(j) == closure) then   ! a closure entry
         stack = j
         j = j + closize      ! step over closure
         !- for (i = offset; lin(i) /= eos; )   ! match as many as possible
         i = offset
         do while ( lin(i) /= eos )                 ! match as many as
            if (omatch_(lin, i, pat, j) == no)then   ! possible
               exit
            endif
         enddo
         pat(stack+count) = i - offset
         pat(stack+start) = offset
         offset = i      ! character that made us fail
      elseif (omatch_(lin, offset, pat, j) == no) then   ! non-closure
!-         for ( ; stack > 0; stack = pat(stack+prevcl))
         do while (stack >0)
            if (pat(stack+count) > 0)then
               exit
            endif
            stack = pat(stack+prevcl)
         enddo
         if (stack <= 0) then      ! stack is empty
            amatch_ = 0            ! return failure
            return
         endif
         pat(stack+count) = pat(stack+count) - 1
         j = stack + closize
         offset = pat(stack+start) + pat(stack+count)
      endif
      j = j + patsiz(pat, j)
   enddo ! else omatch_ succeeded
   epos(1) = offset
   amatch_ = offset
   ! success
end function amatch_
!==================================================================================================================================!
function amatch__(lin_str, from, pat)

$@(#) M_match::amatch

character(len=*),intent(in) :: lin_str
integer,intent(in) :: from
integer(kind=def)  :: amatch__
integer(kind=chr)  :: pat(maxpat)
integer(kind=chr)  :: lin(maxline)
   lin=f2r(lin_str,size(lin))
   amatch__=amatch_(lin,from,pat)
end function amatch__
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file makpat.3m_match.man
NAME
   makpat(3f) - [M_MATCH] make pattern from arg(from), terminate on delim
   (LICENSE:PD)
SYNOPSIS
integer function makpat(arg, from, delim, pat)
DESCRIPTION
 make pattern from arg(from), terminate on delim
OPTIONS
EXAMPLE
AUTHOR
  John S. Urban
REFERENCE
  "Software Tools" by Kernighan and Plauger , 1976
LICENSE
  Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
function makpat_(arg, from, delim, pat)

$@(#) M_match::makpat_ make pattern from arg(from), terminate at delim

integer(kind=def) :: makpat_
integer(kind=chr)  :: arg(maxarg), delim, pat(maxpat)
integer(kind=def) :: from, i, j, junk, lastcl, lastj, lj, nsubs, sp, substk(maxsubs)

   j = 1      ! pat index
   lastj = 1
   lastcl = 0
   nsubs = 0  ! counts number of @(@) pairs
   sp = 0     ! stack pointer for substk
   !-   for (i = from; arg(i) /= delim .and. arg(i) /= eos; i = i + 1) <
   i=from
   do while ( arg(i) /= delim .and. arg(i) /= eos )
      lj = j
      if (arg(i) == any)then
         junk = addset(any, pat, j, maxpat)
      elseif (arg(i) == bol .and. i == from)then
         junk = addset(bol, pat, j, maxpat)
      elseif (arg(i) == eol .and. arg(i + 1) == delim)then
         junk = addset(eol, pat, j, maxpat)
      elseif (arg(i) == ccl) then
         if (getccl(arg, i, pat, j) == err)then
            exit
         endif
      elseif (arg(i) == closure .and. i > from) then
         lj = lastj
         !x!if(pat(lj)==bol .or. pat(lj)==eol .or. pat(lj)==closure .or. pat(lj-1) == boss .or. pat(lj-1) == eoss) then
         if(pat(lj)==bol .or. pat(lj)==eol .or. pat(lj)==closure .or. pat(lj) == boss .or. pat(lj) == eoss) then
            exit
         endif
         lastcl = stclos(pat, j, lastj, lastcl)
      elseif (arg(i) == escape .and. arg(i+1) == lparen) then
         nsubs = nsubs + 1
         if (nsubs >= maxsubs)then
            exit
         endif
         junk = addset(boss, pat, j, maxpat)
         junk = addset(nsubs, pat, j, maxpat)
         sp = sp + 1
         substk(sp) = nsubs
         i = i + 1
      elseif (arg(i) == escape .and. arg(i+1) == rparen) then
         if (sp <= 0)then
            exit
         endif
         junk = addset(eoss, pat, j, maxpat)
         junk = addset(substk(sp), pat, j, maxpat)
         sp = sp - 1
         i = i + 1
      else
         junk = addset(char, pat, j, maxpat)
         junk = addset(esc(arg, i), pat, j, maxpat)
      endif
      lastj = lj
      i=i+1
   enddo
   if (arg(i) /= delim .or. sp /= 0)then   ! terminated early
      makpat_ = err
   elseif (addset(eos, pat, j, maxpat) == no)then   ! no room
      makpat_ = err
   else
      makpat_ = i
   endif
end function makpat_
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file error.3m_match.man
NAME
   error(3f) - [M_MATCH] print message and stop program execution
   (LICENSE:PD)
SYNOPSIS
    subroutine error(line)
DESCRIPTION
   print message and stop program execution
OPTIONS
EXAMPLE
AUTHOR
   John S. Urban
REFERENCE
   "Software Tools" by Kernighan and Plauger , 1976
LICENSE
   Public Domain
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
subroutine error(message)

$@(#) M_match::error(3f): print message and stop program execution

character(len=*),intent(in) :: message
   write(stderr,'(a)')trim(message)
   stop
end subroutine error
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
end module M_match
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
! DECIMAL
! *-------*-------*-------*-------*-------*-------*-------*-------*
! | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|
! | 08 bs | 09 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si |
! | 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb|
! | 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us |
! | 32 sp | 33  ! | 34  " | 35  # | 36  $ | 37  % | 38  & | 39  ' |
! | 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / |
! | 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 |
! | 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? |
! | 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G |
! | 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O |
! | 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W |
! | 88  X | 89  Y | 90  Z | 91  [ | 92  \ | 93  ] | 94  ^ | 95  _ |
! | 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g |
! |104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o |
! |112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w |
! |120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del|
! *-------*-------*-------*-------*-------*-------*-------*-------*
!===================================================================================================================================
! consider
!
! in some, []+ is short for [][]* ;ie one or more of range.
! in some, ?
!
! actually equates $ to a NEWLINE, so $ will not match a string without a NEWLINE at the end; seems like
! should allow EOS to also be seen as equivalent to NEWLINE (?)
!
! seems a bit slow compared to grep(1). Might be inefficient read of input line, but need to profile this and speed up
!
!===================================================================================================================================

RE_FORMAT(7)                                  BSD Miscellaneous Information Manual                                  RE_FORMAT(7)

NAME
     re_format — POSIX 1003.2 regular expressions

DESCRIPTION
     Regular expressions (“REs”), as defined in IEEE Std 1003.2 (“POSIX.2”), come in two forms: modern REs (roughly those of
     egrep(1); 1003.2 calls these “extended” REs) and obsolete REs (roughly those of ed(1); 1003.2 “basic” REs).  Obsolete REs
     mostly exist for backward compatibility in some old programs; they will be discussed at the end.  IEEE Std 1003.2
     (“POSIX.2”) leaves some aspects of RE syntax and semantics open; `‡' marks decisions on these aspects that may not be fully
     portable to other IEEE Std 1003.2 (“POSIX.2”) implementations.

     A (modern) RE is one‡ or more non-empty‡ branches, separated by ‘|’.  It matches anything that matches one of the branches.

     A branch is one‡ or more pieces, concatenated.  It matches a match for the first, followed by a match for the second, etc.

     A piece is an atom possibly followed by a single‡ ‘*’, ‘+’, ‘?’, or bound.    An atom followed by ‘*’ matches a sequence of 0
     or more matches of the atom.  An atom followed by ‘+’ matches a sequence of 1 or more matches of the atom.      An atom fol‐
     lowed by ‘?’ matches a sequence of 0 or 1 matches of the atom.

     A bound is ‘{’ followed by an unsigned decimal integer, possibly followed by ‘,’ possibly followed by another unsigned dec‐
     imal integer, always followed by ‘}’.  The integers must lie between 0 and RE_DUP_MAX (255‡) inclusive, and if there are
     two of them, the first may not exceed the second.  An atom followed by a bound containing one integer i and no comma
     matches a sequence of exactly i matches of the atom.  An atom followed by a bound containing one integer i and a comma
     matches a sequence of i or more matches of the atom.  An atom followed by a bound containing two integers i and j matches a
     sequence of i through j (inclusive) matches of the atom.

     An atom is a regular expression enclosed in ‘()’ (matching a match for the regular expression), an empty set of ‘()’
     (matching the null string)‡, a bracket expression (see below), ‘.’ (matching any single character), ‘^’ (matching the null
     string at the beginning of a line), ‘$’ (matching the null string at the end of a line), a ‘\’ followed by one of the char‐
     acters ‘^.[$()|*+?{\’ (matching that character taken as an ordinary character), a ‘\’ followed by any other character‡
     (matching that character taken as an ordinary character, as if the ‘\’ had not been present‡), or a single character with
     no other significance (matching that character).  A ‘{’ followed by a character other than a digit is an ordinary charac‐
     ter, not the beginning of a bound‡.  It is illegal to end an RE with ‘\’.

     A bracket expression is a list of characters enclosed in ‘[]’.  It normally matches any single character from the list (but
     see below).  If the list begins with ‘^’, it matches any single character (but see below) not from the rest of the list.
     If two characters in the list are separated by ‘-’, this is shorthand for the full range of characters between those two
     (inclusive) in the collating sequence, e.g. ‘[0-9]’ in ASCII matches any decimal digit.  It is illegal‡ for two ranges to
     share an endpoint, e.g. ‘a-c-e’.  Ranges are very collating-sequence-dependent, and portable programs should avoid relying
     on them.

     To include a literal ‘]’ in the list, make it the first character (following a possible ‘^’).  To include a literal ‘-’,
     make it the first or last character, or the second endpoint of a range.  To use a literal ‘-’ as the first endpoint of a
     range, enclose it in ‘[.’ and ‘.]’ to make it a collating element (see below).  With the exception of these and some combi‐
     nations using ‘[’ (see next paragraphs), all other special characters, including ‘\’, lose their special significance
     within a bracket expression.

     Within a bracket expression, a collating element (a character, a multi-character sequence that collates as if it were a
     single character, or a collating-sequence name for either) enclosed in ‘[.’ and ‘.]’ stands for the sequence of characters
     of that collating element.  The sequence is a single element of the bracket expression's list.  A bracket expression con‐
     taining a multi-character collating element can thus match more than one character, e.g. if the collating sequence includes
     a ‘ch’ collating element, then the RE ‘[[.ch.]]*c’ matches the first five characters of ‘chchcc’.

     Within a bracket expression, a collating element enclosed in ‘[=’ and ‘=]’ is an equivalence class, standing for the se‐
     quences of characters of all collating elements equivalent to that one, including itself.  (If there are no other equiva‐
     lent collating elements, the treatment is as if the enclosing delimiters were ‘[.’ and ‘.]’.)  For example, if ‘x’ and ‘y’
     are the members of an equivalence class, then ‘[[=x=]]’, ‘[[=y=]]’, and ‘[xy]’ are all synonymous.      An equivalence class
     may not‡ be an endpoint of a range.

     Within a bracket expression, the name of a character class enclosed in ‘[:’ and ‘:]’ stands for the list of all characters
     belonging to that class.  Standard character class names are:

           alnum    digit    punct
           alpha    graph    space
           blank    lower    upper
           cntrl    print    xdigit

     These stand for the character classes defined in ctype(3).  A locale may provide others.  A character class may not be used
     as an endpoint of a range.

     A bracketed expression like ‘[[:class:]]’ can be used to match a single character that belongs to a character class.  The
     reverse, matching any character that does not belong to a specific class, the negation operator of bracket expressions may
     be used: ‘[^[:class:]]’.

     There are two special cases‡ of bracket expressions: the bracket expressions ‘[[:<:]]’ and ‘[[:>:]]’ match the null string
     at the beginning and end of a word respectively.  A word is defined as a sequence of word characters which is neither pre‐
     ceded nor followed by word characters.  A word character is an alnum character (as defined by ctype(3)) or an underscore.
     This is an extension, compatible with but not specified by IEEE Std 1003.2 (“POSIX.2”), and should be used with caution in
     software intended to be portable to other systems.

     In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in
     the string.  If the RE could match more than one substring starting at that point, it matches the longest.  Subexpressions
     also match the longest possible substrings, subject to the constraint that the whole match be as long as possible, with
     subexpressions starting earlier in the RE taking priority over ones starting later.  Note that higher-level subexpressions
     thus take priority over their lower-level component subexpressions.

     Match lengths are measured in characters, not collating elements.  A null string is considered longer than no match at all.
     For example, ‘bb*’ matches the three middle characters of ‘abbbc’, ‘(wee|week)(knights|nights)’ matches all ten characters
     of ‘weeknights’, when ‘(.*).*’ is matched against ‘abc’ the parenthesized subexpression matches all three characters, and
     when ‘(a*)*’ is matched against ‘bc’ both the whole RE and the parenthesized subexpression match the null string.

     If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet.
     When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is ef‐
     fectively transformed into a bracket expression containing both cases, e.g. ‘x’ becomes ‘[xX]’.  When it appears inside a
     bracket expression, all case counterparts of it are added to the bracket expression, so that (e.g.)  ‘[x]’ becomes ‘[xX]’
     and ‘[^x]’ becomes ‘[^xX]’.

     No particular limit is imposed on the length of REs‡.  Programs intended to be portable should not employ REs longer than
     256 bytes, as an implementation can refuse to accept such REs and remain POSIX-compliant.

     Obsolete (“basic”) regular expressions differ in several respects.      ‘|’ is an ordinary character and there is no equivalent
     for its functionality.  ‘+’ and ‘?’ are ordinary characters, and their functionality can be expressed using bounds (‘{1,}’
     or ‘{0,1}’ respectively).      Also note that ‘x+’ in modern REs is equivalent to ‘xx*’.  The delimiters for bounds are ‘\{’
     and ‘\}’, with ‘{’ and ‘}’ by themselves ordinary characters.  The parentheses for nested subexpressions are ‘\(’ and ‘\)’,
     with ‘(’ and ‘)’ by themselves ordinary characters.  ‘^’ is an ordinary character except at the beginning of the RE or‡ the
     beginning of a parenthesized subexpression, ‘$’ is an ordinary character except at the end of the RE or‡ the end of a
     parenthesized subexpression, and ‘*’ is an ordinary character if it appears at the beginning of the RE or the beginning of
     a parenthesized subexpression (after a possible leading ‘^’).  Finally, there is one new type of atom, a back reference:
     ‘\’ followed by a non-zero decimal digit d matches the same sequence of characters matched by the dth parenthesized subex‐
     pression (numbering subexpressions by the positions of their opening parentheses, left to right), so that (e.g.)
     ‘\([bc]\)\1’ matches ‘bb’ or ‘cc’ but not ‘bc’.
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
Regular expressions (regex or regexp) are extremely useful in extracting
information from any text by searching for one or more matches of a
specific search pattern (i.e. a specific sequence of ASCII or unicode
characters).

Fields of application range from validation to parsing/replacing strings,
passing through translating data to other formats and web scraping.

One of the most interesting features is that once you’ve learned
the syntax, you can actually use this tool in (almost) all programming
languages ​​(JavaScript, Java, VB, C #, C / C++, Python, Perl, Ruby,
Delphi, R, Tcl, and many others) with the slightest distinctions about
the support of the most advanced features and syntax versions supported
by the engines).

Let’s start by looking at some examples and explanations.
Basic topics
Anchors — ^ and $

^The        matches any string that starts with The -> Try it!end$
matches a string that ends with end^The end$   exact string match (starts
and ends with The end)roar        matches any string that has the text
roar in it

Quantifiers — * + ? and {}

abc*        matches a string that has ab followed by zero or more c -> Try
it!abc+        matches a string that has ab followed by one or more cabc?
matches a string that has ab followed by zero or one cabc{2}      matches
a string that has ab followed by 2 cabc{2,}     matches a string that
has ab followed by 2 or more cabc{2,5}    matches a string that has ab
followed by 2 up to 5 ca(bc)*      matches a string that has a followed
by zero or more copies of the sequence bca(bc){2,5}  matches a string
that has a followed by 2 up to 5 copies of the sequence bc

OR operator — | or []

a(b|c)     matches a string that has a followed by b or c (and captures b
or c) -> Try it!a[bc]      same as previous, but without capturing b or c

Character classes — \d \w \s and .

\d         matches a single character that is a digit -> Try it!\w
matches a word character (alphanumeric character plus underscore) ->
Try it!\s         matches a whitespace character (includes tabs and
line breaks).          matches any character -> Try it!

Use the . operator carefully since often class or negated character class
(which we’ll cover next) are faster and more precise.

\d, \w and \s also present their negations with \D, \W and \S respectively.

For example, \D will perform the inverse match with respect to that
obtained with \d.

\D         matches a single non-digit character -> Try it!

In order to be taken literally, you must escape the characters
^.[$()|*+?{\with a backslash \ as they have special meaning.

\$\d       matches a string that has a $ before one digit -> Try it!

Notice that you can match also non-printable characters like tabs \t,
new-lines \n, carriage returns \r.  Flags

We are learning how to construct a regex but forgetting a fundamental
concept: flags.

A regex usually comes within this form /abc/, where the search pattern
is delimited by two slash characters /. At the end we can specify a flag
with these values (we can also combine them each other):

    g (global) does not return after the first match, restarting the
    subsequent searches from the end of the previous match

    m (multi-line) when enabled ^ and $ will match the start and end of
    a line, instead of the whole string

    i (insensitive) makes the whole expression case-insensitive (for
    instance /aBc/i would match AbC)

Intermediate topics
Grouping and capturing — ()

a(bc)           parentheses create a capturing group with value bc ->
Try it!a(?:bc)*        using ?: we disable the capturing group -> Try
it!a(?<foo>bc)     using ?<foo> we put a name to the group -> Try it!

This operator is very useful when we need to extract information from
strings or data using your preferred programming language. Any multiple
occurrences captured by several groups will be exposed in the form of a
classical array: we will access their values specifying using an index
on the result of the match.

If we choose to put a name to the groups (using (?<foo>...)) we will be
able to retrieve the group values using the match result like a dictionary
where the keys will be the name of each group.
Bracket expressions — []

[abc]            matches a string that has either an a or a b or a c -> is
the same as a|b|c -> Try it![a-c]            same as previous[a-fA-F0-9]
a string that represents a single hexadecimal digit, case insensitively ->
Try it![0-9]%           a string that has a character from 0 to 9 before
a % sign[^a-zA-Z]        a string that has not a letter from a to z or
from A to Z. In this case the ^ is used as negation of the expression ->
Try it!

Remember that inside bracket expressions all special characters (including
the backslash \) lose their special powers: thus we will not apply the
“escape rule”.  Greedy and Lazy match

The quantifiers ( * + {}) are greedy operators, so they expand the match
as far as they can through the provided text.

For example, <.+> matches <div>simple div</div> in This is a <div>
simple div</div> test. In order to catch only the div tag we can use a
? to make it lazy:

<.+?>            matches any character one or more times included inside <
and >, expanding as needed -> Try it!

Notice that a better solution should avoid the usage of . in favor of
a more strict regex:

<[^<>]+>         matches any character except < or > one or more times
included inside < and > -> Try it!

Advanced topics
Boundaries — \b and \B

\babc\b          performs a "whole words only" search -> Try it!

\b represents an anchor like caret (it is similar to $ and ^) matching
positions where one side is a word character (like \w) and the other
side is not a word character (for instance it may be the beginning of
the string or a space character).

It comes with its negation, \B. This matches all positions where \b
doesn’t match and could be if we want to find a search pattern fully
surrounded by word characters.

\Babc\B          matches only if the pattern is fully surrounded by word
characters -> Try it!

Back-references — \1

([abc])\1              using \1 it matches the same text that was matched
by the first capturing group -> Try it!([abc])([de])\2\1      we can use
\2 (\3, \4, etc.) to identify the same text that was matched by the second
(third, fourth, etc.) capturing group -> Try it!(?<foo>[abc])\k<foo>
we put the name foo to the group and we reference it later (\k<foo>). The
result is the same of the first regex -> Try it!

Look-ahead and Look-behind — (?=) and (?<=)

d(?=r)       matches a d only if is followed by r, but r will not be part
of the overall regex match -> Try it!(?<=r)d      matches a d only if is
preceded by an r, but r will not be part of the overall regex match ->
Try it!

You can use also the negation operator!

d(?!r)       matches a d only if is not followed by r, but r will not
be part of the overall regex match -> Try it!(?<!r)d      matches a d
only if is not preceded by an r, but r will not be part of the overall
regex match -> Try it!

Summary

As you’ve seen, the application fields of regex can be multiple and
I’m sure that you’ve recognized at least one of these tasks among
those seen in your developer career, here a quick list:

    data validation (for example check if a time string is well-formed)

    data scraping (especially web scraping, find all pages that contain
    a certain set of words eventually in a specific order)

    data wrangling (transform data from “raw” to another format)

    string parsing (for example catch all URL GET parameters, capture
    text inside a set of parenthesis)

    string replacement (for example, even during a code session using a
    common IDE to translate a Java or C# class in the respective JSON
    object — replace “;” with “,” make it lowercase, avoid
    type declaration, etc.)

    syntax highlightning, file renaming, packet sniffing and many other
    applications involving strings (where data need not be textual)

$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL
module M_BRE
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit

! allow ratfor strings and Fortran strings

public   match;   interface  match;   module  procedure  match_,   match__;   end  interface
public   getpat;  interface  getpat;  module  procedure  getpat_,  getpat__;  end  interface
public   amatch;  interface  amatch;  module  procedure  amatch_,  amatch__;  end  interface
public   makpat;  interface  makpat;  module  procedure  makpat_   ;          end  interface
public   error;   interface  error;   module  procedure  error_    ;          end  interface
private  addset;  interface  addset;  module  procedure  addset_   ;          end  interface
private  dodash;  interface  dodash;  module  procedure  dodash_   ;          end  interface
private  esc;     interface  esc;     module  procedure  esc_      ;          end  interface
private  filset;  interface  filset;  module  procedure  filset_   ;          end  interface
private  getccl;  interface  getccl;  module  procedure  getccl_   ;          end  interface
private  indx;    interface  indx;    module  procedure  indx_     ;          end  interface
private  locate;  interface  locate;  module  procedure  locate_   ;          end  interface
private  omatch;  interface  omatch;  module  procedure  omatch_   ;          end  interface
private  patsiz;  interface  patsiz;  module  procedure  patsiz_   ;          end  interface
private  stclos;  interface  stclos;  module  procedure  stclos_   ;          end  interface

public YES
public NO
public MAXPAT
public MAXARG
public MAXLINE
public MAXTAGS
public EOS
public NEWLINE
public ERR

integer,parameter :: MAXPAT=1024
integer,parameter :: MAXARG=1024
integer,parameter :: MAXLINE=1024
integer,parameter :: MAXTAGS=10

public regex_pattern
type :: regex_pattern
   integer :: pat(MAXPAT)
end type regex_pattern

integer,parameter :: CLOSURE=ichar('*') ! *    *
integer,parameter :: EOL=ichar('$')     ! $    $
integer,parameter :: ANY=ichar('.')     ! ?    .
integer,parameter :: BOL=ichar('^')     ! %    ^
integer,parameter :: NCCL=ichar('n')    ! n    n
integer,parameter :: NOT=ichar('^')     ! ~    ~  processed only in a CCL, so can be same as BOL, which is only special when first
integer,parameter :: CCL=ichar('[')     ! [    [
integer,parameter :: CCLEND=ichar(']')  ! ]    ]
integer,parameter :: ESCAP=ichar('\')   ! @    \
!! OTHER CALLS START_TAG BOSS AND STOP_TAG EOSS AND USES < AND >
integer,parameter :: START_TAG=ichar('{')  ! {    [
integer,parameter :: STOP_TAG=ichar('}')   ! }    ]
!! DUPLICATE
integer,parameter :: BOSS=ichar('{')  ! {    [
integer,parameter :: EOSS=ichar('}')  ! }    ]

integer,parameter :: DASH=ichar('-')
integer,parameter :: CHARA=ichar('a')
integer,parameter :: LETB=ichar('B'), CHARB=ichar('b')
integer,parameter :: LETN=ichar('N'), CHARN=ichar('n')
integer,parameter :: LETR=ichar('R'), CHARR=ichar('r')
integer,parameter :: LETT=ichar('T'), CHART=ichar('t')
integer,parameter :: NEWLINE=10
integer,parameter :: BACKSPACE=8
integer,parameter :: HT=9   ! horizontal tab
integer,parameter :: CR=13  ! carriage return
integer,parameter :: BADCHAR=0
integer,parameter :: EOS=-2
integer,parameter :: ERR=-3

integer,parameter :: START=3
integer,parameter :: CLOSIZE=4
integer,parameter :: NO=0
integer,parameter :: YES=1

integer,parameter :: DIG0=48
integer,parameter :: DIG1=49
integer,parameter :: DIG2=50
integer,parameter :: DIG3=51
integer,parameter :: DIG4=52
integer,parameter :: DIG5=53
integer,parameter :: DIG6=54
integer,parameter :: DIG7=55
integer,parameter :: DIG8=56
integer,parameter :: DIG9=57
contains
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
integer function match_(lin, pat)

   integer :: lin(MAXLINE)
   integer :: pat(MAXPAT)
   integer :: i
   integer :: junk(MAXTAGS)
   i = 1
   match_ = NO
!! OTHER  if(pat(1) == bol) then            ! anchored match
!! OTHER    if(amatch_(lin, 1, pat) > 0) then
!! OTHER        match_ = yes
!! OTHER        return
!! OTHER     endif
!! OTHER  else ! unanchored match
   do while(lin(i) /= EOS)
      if(amatch_(lin, i, pat, junk, junk) .gt. 0)then
         match_ = YES
         exit
      endif
      i = i + 1
   enddo
!! OTHER  endif

end function match_
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
integer function makpat_(arg, from, delim, pat)

   integer arg(MAXARG)
   integer from
   integer delim
   integer pat(MAXPAT)
   integer i, j, junk, lastcl, lastj, lj, tagnst, tagnum, tagstk(MAXTAGS)

   j = 1        ! pat index
   lastj = 1
   lastcl = BADCHAR !! OTHER SETS THIS TO -1
   tagnum = 0
   tagnst = 0
   i = from
   MAKPATIT: do while(arg(i) /= delim .and. arg(i) /= EOS)
      lj = j
      if(arg(i) .eq. ANY)then
         junk = addset_(ANY, pat, j, MAXPAT)
      elseif(arg(i) .eq. BOL .and. i .eq. from)then
         junk = addset_(BOL, pat, j, MAXPAT)
      elseif(arg(i) .eq. EOL .and. arg(i + 1) .eq. delim)then
         junk = addset_(EOL, pat, j, MAXPAT)
      elseif(arg(i) .eq. CCL)then
         if(getccl_(arg, i, pat, j) .eq. ERR)then
            makpat_ = ERR
            return  !! OTHERS SAY EXIT
         endif
      elseif(arg(i) .eq. CLOSURE .and. i .gt. from)then
         lj = lastj
         !! OTHER if(pat(lj).eq.BOL.or.pat(lj).eq.EOL.or.pat(lj).eq.CLOSURE.or.pat(lj-1).eq.START_TAG.or.pat(lj-1).eq.STOP_TAG)then
         if(pat(lj).eq.BOL.or.pat(lj).eq.EOL.or.pat(lj).eq.CLOSURE.or.pat(lj).eq.START_TAG.or.pat(lj).eq.STOP_TAG)then
            exit MAKPATIT
         endif
         lastcl = stclos_(pat, j, lastj, lastcl)
      elseif(arg(i) .eq. START_TAG)then
         if(tagnum .ge. MAXTAGS)then
            ! too many tagged sub-patterns
            exit MAKPATIT
         endif
         tagnum = tagnum + 1
         tagnst = tagnst + 1
         tagstk(tagnst) = tagnum
         junk = addset_(START_TAG, pat, j, MAXPAT)
         junk = addset_(tagnum, pat, j, MAXPAT)
      elseif(arg(i) .eq. STOP_TAG .and. tagnst .gt. 0)then
         junk = addset_(STOP_TAG, pat, j, MAXPAT)
         junk = addset_(tagstk(tagnst), pat, j, MAXPAT)
         tagnst = tagnst - 1
      else
         junk = addset_(CHARA, pat, j, MAXPAT)
         junk = addset_(esc_(arg, i), pat, j, MAXPAT)
      endif
      lastj = lj
      i = i + 1
   enddo MAKPATIT
   if(arg(i) .ne. delim)then
      ! terminated early
      makpat_ = ERR
   elseif(addset_(EOS, pat, j, MAXPAT) .eq. NO)then
      ! no room
      makpat_ = ERR
   elseif(tagnst .ne. 0)then
      makpat_ = ERR
   else
      makpat_ = i
   endif
end function makpat_
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
integer function amatch__(line, from, pat, tagbeg, tagend)

character(len=*),intent(in) :: line
integer                     :: from
integer                     :: pat(MAXPAT)
integer                     :: tagbeg(MAXTAGS), tagend(MAXTAGS)
integer                     :: lin(MAXLINE)
integer                     :: len_line
   len_line=len(line)
   if(len_line.gt.MAXLINE-1)then
      write(*,*)'*amatch* error: input string too long,',len_line,' > ',MAXLINE-2
      stop
   else
      lin(1:len_line+1)=f2r(line) ! convert string to ADE array
      amatch__=amatch_(lin,from,pat,tagbeg,tagend)
   endif
end function amatch__

integer function amatch_(lin, from, pat, tagbeg, tagend)

integer :: lin(MAXLINE)
integer :: pat(MAXPAT)
integer from, tagbeg(MAXTAGS), tagend(MAXTAGS)
integer i, j, offset, stack
   ! zero out tag data
   tagbeg = 0
   tagend = 0
   tagbeg(1) = from
   stack = 0
   offset = from
   j = 1
   MATCHIT: do
      select case(pat(j))
       case(EOS)
         exit MATCHIT
       case(CLOSURE)
         stack = j
         j = j + CLOSIZE
         i = offset
         OMATCHIT: do
            if(.not.(lin(i) .ne. EOS))exit OMATCHIT
            ! match as many as possible
            if(omatch_(lin, i, pat, j) .eq. NO) exit OMATCHIT
         enddo OMATCHIT
         pat(stack + 1) = i - offset   !! OTHER SAYS COUNT INSTEAD OF 1
         pat(stack + START) = offset
         offset = i  ! character that made us fail
       case(START_TAG)
         i = pat(j + 1)
         tagbeg(i + 1) = offset
       case(STOP_TAG)
         i = pat(j + 1)
         tagend(i + 1) = offset
       case default
         if(omatch_(lin, offset, pat, j) .eq. NO)then
            ! non-closure
            STACKIT: do
               if(stack .le. 0)exit STACKIT
               if(pat(stack + 1) .gt. 0) exit STACKIT  !! OTHER SAYS COUNT INSTEAD OF 1
               stack = pat(stack + 2)  !! OTHER SAYS PREVCL INSTEAD OF 2
            enddo STACKIT
            if(stack .le. 0)then  ! stack is empty
               amatch_ = NO         ! return failure
               return
            endif
            pat(stack + 1) = pat(stack + 1) - 1 !! OTHER SAYS + COUNT INSTEAD OF + 1
            j = stack + CLOSIZE
            offset = pat(stack + START) + pat(stack + 1) !! OTHER SAYS 1==>COUNT
         endif
      end select
      ! else omatch succeeded
      j = j + patsiz_(pat, j)
   enddo MATCHIT
   amatch_ = offset
   tagend(1) = offset
end function amatch_
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
integer function omatch_(lin, i, pat, j)

integer :: lin(MAXLINE)
integer :: pat(MAXPAT)
integer :: i, j, k
integer :: bump
   omatch_ = NO
   if(lin(i) .ne. EOS)then
      bump = -1
      select case(pat(j))
       case(CHARA);  if(lin(i) .eq. pat(j + 1))                   bump = 1
       case(BOL);    if(i .eq. 1)                                 bump = 0
       case(ANY);    if(lin(i) .ne. NEWLINE)                      bump = 1
       case(EOL);    if(lin(i) .eq. NEWLINE .or. lin(i) .eq. EOS) bump = 0
       case(CCL);    if(locate_(lin(i), pat, j + 1) .eq. YES)    bump = 1
       case(NCCL);   if(lin(i).ne. NEWLINE .and. locate_(lin(i), pat, j + 1) .eq. NO) bump = 1
       !! OTHER case(START_TAG)
          !! OTHER k=pat(j+1)
          !! OTHER bpos(k+1) = i
          !! OTHER bump = 0
       !! OTHER case(END_TAG)
          !! OTHER k=pat(j+1)
          !! OTHER epos(k+1) = i
          !! OTHER bump = 0
       case default; call error("in omatch: cannot happen.")
      end select
      if(bump .ge. 0)then
         i = i + bump
         omatch_ = YES
      endif
   endif
end function omatch_
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
end module M_BRE
$BLOCK
